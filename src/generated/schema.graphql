### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateDashboard {
  avg: DashboardAvgAggregateOutputType!
  count: Int!
  max: DashboardMaxAggregateOutputType!
  min: DashboardMinAggregateOutputType!
  sum: DashboardSumAggregateOutputType!
}

type AggregateGroup {
  avg: GroupAvgAggregateOutputType!
  count: Int!
  max: GroupMaxAggregateOutputType!
  min: GroupMinAggregateOutputType!
  sum: GroupSumAggregateOutputType!
}

type AggregateJob {
  avg: JobAvgAggregateOutputType!
  count: Int!
  max: JobMaxAggregateOutputType!
  min: JobMinAggregateOutputType!
  sum: JobSumAggregateOutputType!
}

type AggregateJobRun {
  avg: JobRunAvgAggregateOutputType!
  count: Int!
  max: JobRunMaxAggregateOutputType!
  min: JobRunMinAggregateOutputType!
  sum: JobRunSumAggregateOutputType!
}

type AggregateJournalEntry {
  avg: JournalEntryAvgAggregateOutputType!
  count: Int!
  max: JournalEntryMaxAggregateOutputType!
  min: JournalEntryMinAggregateOutputType!
  sum: JournalEntrySumAggregateOutputType!
}

type AggregateSection {
  avg: SectionAvgAggregateOutputType!
  count: Int!
  max: SectionMaxAggregateOutputType!
  min: SectionMinAggregateOutputType!
  sum: SectionSumAggregateOutputType!
}

type AggregateStep {
  avg: StepAvgAggregateOutputType!
  count: Int!
  max: StepMaxAggregateOutputType!
  min: StepMinAggregateOutputType!
  sum: StepSumAggregateOutputType!
}

type AggregateUser {
  avg: UserAvgAggregateOutputType!
  count: Int!
  max: UserMaxAggregateOutputType!
  min: UserMinAggregateOutputType!
  sum: UserSumAggregateOutputType!
}

type BatchPayload {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Dashboard {
  createdAt: DateTime!
  groups(cursor: GroupWhereUniqueInput, distinct: GroupDistinctFieldEnum, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): [Group!]!
  id: Int!
  minuteOffset: Int!
  name: String!
  published: Boolean!
  sections(cursor: SectionWhereUniqueInput, distinct: SectionDistinctFieldEnum, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): [Section!]!
  updatedAt: DateTime!
}

type DashboardAvgAggregateOutputType {
  id: Float!
  minuteOffset: Float!
}

input DashboardCreateInput {
  createdAt: DateTime
  groups: GroupCreateManyWithoutDashboardsInput
  minuteOffset: Int
  name: String!
  published: Boolean
  sections: SectionCreateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardCreateManyWithoutGroupsInput {
  connect: [DashboardWhereUniqueInput!]
  create: [DashboardCreateWithoutGroupsInput!]
}

input DashboardCreateOneWithoutSectionsInput {
  connect: DashboardWhereUniqueInput
  create: DashboardCreateWithoutSectionsInput
}

input DashboardCreateWithoutGroupsInput {
  createdAt: DateTime
  minuteOffset: Int
  name: String!
  published: Boolean
  sections: SectionCreateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardCreateWithoutSectionsInput {
  createdAt: DateTime
  groups: GroupCreateManyWithoutDashboardsInput
  minuteOffset: Int
  name: String!
  published: Boolean
  updatedAt: DateTime
}

enum DashboardDistinctFieldEnum {
  createdAt
  id
  minuteOffset
  name
  published
  updatedAt
}

input DashboardListRelationFilter {
  every: DashboardWhereInput
  none: DashboardWhereInput
  some: DashboardWhereInput
}

type DashboardMaxAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

type DashboardMinAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

input DashboardOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  minuteOffset: SortOrder
  name: SortOrder
  published: SortOrder
  updatedAt: SortOrder
}

input DashboardRelationFilter {
  is: DashboardWhereInput
  isNot: DashboardWhereInput
}

input DashboardScalarWhereInput {
  AND: [DashboardScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  minuteOffset: IntFilter
  name: StringFilter
  NOT: [DashboardScalarWhereInput!]
  OR: [DashboardScalarWhereInput!]
  published: BoolFilter
  updatedAt: DateTimeFilter
}

type DashboardSumAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

input DashboardUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  groups: GroupUpdateManyWithoutDashboardsInput
  minuteOffset: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  sections: SectionUpdateManyWithoutDashboardInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DashboardUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  minuteOffset: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DashboardUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  minuteOffset: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DashboardUpdateManyWithoutGroupsInput {
  connect: [DashboardWhereUniqueInput!]
  create: [DashboardCreateWithoutGroupsInput!]
  delete: [DashboardWhereUniqueInput!]
  deleteMany: [DashboardScalarWhereInput!]
  disconnect: [DashboardWhereUniqueInput!]
  set: [DashboardWhereUniqueInput!]
  update: [DashboardUpdateWithWhereUniqueWithoutGroupsInput!]
  updateMany: [DashboardUpdateManyWithWhereNestedInput!]
  upsert: [DashboardUpsertWithWhereUniqueWithoutGroupsInput!]
}

input DashboardUpdateManyWithWhereNestedInput {
  data: DashboardUpdateManyDataInput!
  where: DashboardScalarWhereInput!
}

input DashboardUpdateOneWithoutSectionsInput {
  connect: DashboardWhereUniqueInput
  create: DashboardCreateWithoutSectionsInput
  delete: Boolean
  disconnect: Boolean
  update: DashboardUpdateWithoutSectionsDataInput
  upsert: DashboardUpsertWithoutSectionsInput
}

input DashboardUpdateWithoutGroupsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  minuteOffset: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  sections: SectionUpdateManyWithoutDashboardInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DashboardUpdateWithoutSectionsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  groups: GroupUpdateManyWithoutDashboardsInput
  minuteOffset: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DashboardUpdateWithWhereUniqueWithoutGroupsInput {
  data: DashboardUpdateWithoutGroupsDataInput!
  where: DashboardWhereUniqueInput!
}

input DashboardUpsertWithoutSectionsInput {
  create: DashboardCreateWithoutSectionsInput!
  update: DashboardUpdateWithoutSectionsDataInput!
}

input DashboardUpsertWithWhereUniqueWithoutGroupsInput {
  create: DashboardCreateWithoutGroupsInput!
  update: DashboardUpdateWithoutGroupsDataInput!
  where: DashboardWhereUniqueInput!
}

input DashboardWhereInput {
  AND: [DashboardWhereInput!]
  createdAt: DateTimeFilter
  groups: GroupListRelationFilter
  id: IntFilter
  minuteOffset: IntFilter
  name: StringFilter
  NOT: [DashboardWhereInput!]
  OR: [DashboardWhereInput!]
  published: BoolFilter
  sections: SectionListRelationFilter
  updatedAt: DateTimeFilter
}

input DashboardWhereUniqueInput {
  id: Int
  name: String
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Enum {
  fields: [String!]!
  name: String!
}

input EnumJobStatusFieldUpdateOperationsInput {
  set: JobStatus
}

input EnumJobStatusFilter {
  equals: JobStatus
  in: [JobStatus!]
  not: NestedEnumJobStatusFilter
  notIn: [JobStatus!]
}

input EnumJobTypeNullableFilter {
  equals: JobType
  in: [JobType!]
  not: NestedEnumJobTypeNullableFilter
  notIn: [JobType!]
}

type Field {
  create: Boolean!
  editor: Boolean!
  filter: Boolean!
  id: String!
  isId: Boolean!
  kind: KindEnum!
  list: Boolean!
  name: String!
  order: Int!
  read: Boolean!
  relationField: Boolean
  required: Boolean!
  sort: Boolean!
  title: String!
  type: String!
  unique: Boolean!
  update: Boolean!
  upload: Boolean!
}

type Group {
  createdAt: DateTime!
  dashboards(cursor: DashboardWhereUniqueInput, distinct: DashboardDistinctFieldEnum, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): [Dashboard!]!
  id: Int!
  name: String!
  updatedAt: DateTime!
  users(cursor: UserWhereUniqueInput, distinct: UserDistinctFieldEnum, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type GroupAvgAggregateOutputType {
  id: Float!
}

input GroupCreateInput {
  createdAt: DateTime
  dashboards: DashboardCreateManyWithoutGroupsInput
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutGroupInput
}

input GroupCreateManyWithoutDashboardsInput {
  connect: [GroupWhereUniqueInput!]
  create: [GroupCreateWithoutDashboardsInput!]
}

input GroupCreateOneWithoutUsersInput {
  connect: GroupWhereUniqueInput
  create: GroupCreateWithoutUsersInput
}

input GroupCreateWithoutDashboardsInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutGroupInput
}

input GroupCreateWithoutUsersInput {
  createdAt: DateTime
  dashboards: DashboardCreateManyWithoutGroupsInput
  name: String!
  updatedAt: DateTime
}

enum GroupDistinctFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input GroupListRelationFilter {
  every: GroupWhereInput
  none: GroupWhereInput
  some: GroupWhereInput
}

type GroupMaxAggregateOutputType {
  id: Int!
}

type GroupMinAggregateOutputType {
  id: Int!
}

input GroupOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GroupRelationFilter {
  is: GroupWhereInput
  isNot: GroupWhereInput
}

input GroupScalarWhereInput {
  AND: [GroupScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [GroupScalarWhereInput!]
  OR: [GroupScalarWhereInput!]
  updatedAt: DateTimeFilter
}

type GroupSumAggregateOutputType {
  id: Int!
}

input GroupUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dashboards: DashboardUpdateManyWithoutGroupsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: UserUpdateManyWithoutGroupInput
}

input GroupUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GroupUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GroupUpdateManyWithoutDashboardsInput {
  connect: [GroupWhereUniqueInput!]
  create: [GroupCreateWithoutDashboardsInput!]
  delete: [GroupWhereUniqueInput!]
  deleteMany: [GroupScalarWhereInput!]
  disconnect: [GroupWhereUniqueInput!]
  set: [GroupWhereUniqueInput!]
  update: [GroupUpdateWithWhereUniqueWithoutDashboardsInput!]
  updateMany: [GroupUpdateManyWithWhereNestedInput!]
  upsert: [GroupUpsertWithWhereUniqueWithoutDashboardsInput!]
}

input GroupUpdateManyWithWhereNestedInput {
  data: GroupUpdateManyDataInput!
  where: GroupScalarWhereInput!
}

input GroupUpdateOneWithoutUsersInput {
  connect: GroupWhereUniqueInput
  create: GroupCreateWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  update: GroupUpdateWithoutUsersDataInput
  upsert: GroupUpsertWithoutUsersInput
}

input GroupUpdateWithoutDashboardsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: UserUpdateManyWithoutGroupInput
}

input GroupUpdateWithoutUsersDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dashboards: DashboardUpdateManyWithoutGroupsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GroupUpdateWithWhereUniqueWithoutDashboardsInput {
  data: GroupUpdateWithoutDashboardsDataInput!
  where: GroupWhereUniqueInput!
}

input GroupUpsertWithoutUsersInput {
  create: GroupCreateWithoutUsersInput!
  update: GroupUpdateWithoutUsersDataInput!
}

input GroupUpsertWithWhereUniqueWithoutDashboardsInput {
  create: GroupCreateWithoutDashboardsInput!
  update: GroupUpdateWithoutDashboardsDataInput!
  where: GroupWhereUniqueInput!
}

input GroupWhereInput {
  AND: [GroupWhereInput!]
  createdAt: DateTimeFilter
  dashboards: DashboardListRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  updatedAt: DateTimeFilter
  users: UserListRelationFilter
}

input GroupWhereUniqueInput {
  id: Int
  name: String
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Job {
  createdAt: DateTime!
  id: Int!
  jobType: JobType
  name: String!
  runs(cursor: JobRunWhereUniqueInput, distinct: JobRunDistinctFieldEnum, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): [JobRun!]!
  Steps(cursor: StepWhereUniqueInput, distinct: StepDistinctFieldEnum, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]!
  updatedAt: DateTime!
}

type JobAvgAggregateOutputType {
  id: Float!
}

input JobCreateInput {
  createdAt: DateTime
  id: Int!
  jobType: JobType
  name: String!
  runs: JobRunCreateManyWithoutJobInput
  Steps: StepCreateManyWithoutJobInput
  updatedAt: DateTime
}

input JobCreateOneWithoutRunsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutRunsInput
}

input JobCreateOneWithoutStepsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutStepsInput
}

input JobCreateWithoutRunsInput {
  createdAt: DateTime
  id: Int!
  jobType: JobType
  name: String!
  Steps: StepCreateManyWithoutJobInput
  updatedAt: DateTime
}

input JobCreateWithoutStepsInput {
  createdAt: DateTime
  id: Int!
  jobType: JobType
  name: String!
  runs: JobRunCreateManyWithoutJobInput
  updatedAt: DateTime
}

enum JobDistinctFieldEnum {
  createdAt
  id
  jobType
  name
  updatedAt
}

input JobIdStartTimeCompoundUniqueInput {
  jobId: Int!
  startTime: DateTime!
}

type JobMaxAggregateOutputType {
  id: Int!
}

type JobMinAggregateOutputType {
  id: Int!
}

input JobOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  jobType: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input JobRelationFilter {
  is: JobWhereInput
  isNot: JobWhereInput
}

type JobRun {
  createdAt: DateTime!
  endTime: DateTime
  exitCode: Int
  id: Int!
  job: Job!
  jobId: Int!
  jobRunId: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus!
  updatedAt: DateTime!
}

type JobRunAvgAggregateOutputType {
  exitCode: Float!
  id: Float!
  jobId: Float!
  jobRunId: Float!
}

input JobRunCreateInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  job: JobCreateOneWithoutRunsInput!
  jobRunId: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus
  updatedAt: DateTime
}

input JobRunCreateManyWithoutJobInput {
  connect: [JobRunWhereUniqueInput!]
  create: [JobRunCreateWithoutJobInput!]
}

input JobRunCreateWithoutJobInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  jobRunId: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus
  updatedAt: DateTime
}

enum JobRunDistinctFieldEnum {
  createdAt
  endTime
  exitCode
  id
  jobId
  jobRunId
  moreInfo
  startTime
  status
  updatedAt
}

input JobRunListRelationFilter {
  every: JobRunWhereInput
  none: JobRunWhereInput
  some: JobRunWhereInput
}

type JobRunMaxAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
}

type JobRunMinAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
}

input JobRunOrderByInput {
  createdAt: SortOrder
  endTime: SortOrder
  exitCode: SortOrder
  id: SortOrder
  jobId: SortOrder
  jobRunId: SortOrder
  moreInfo: SortOrder
  startTime: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

input JobRunScalarWhereInput {
  AND: [JobRunScalarWhereInput!]
  createdAt: DateTimeFilter
  endTime: DateTimeNullableFilter
  exitCode: IntNullableFilter
  id: IntFilter
  jobId: IntFilter
  jobRunId: IntNullableFilter
  moreInfo: StringNullableFilter
  NOT: [JobRunScalarWhereInput!]
  OR: [JobRunScalarWhereInput!]
  startTime: DateTimeFilter
  status: EnumJobStatusFilter
  updatedAt: DateTimeFilter
}

type JobRunSumAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
}

input JobRunUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: NullableDateTimeFieldUpdateOperationsInput
  exitCode: NullableIntFieldUpdateOperationsInput
  job: JobUpdateOneRequiredWithoutRunsInput
  jobRunId: NullableIntFieldUpdateOperationsInput
  moreInfo: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  status: EnumJobStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobRunUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: NullableDateTimeFieldUpdateOperationsInput
  exitCode: NullableIntFieldUpdateOperationsInput
  jobRunId: NullableIntFieldUpdateOperationsInput
  moreInfo: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  status: EnumJobStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobRunUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: NullableDateTimeFieldUpdateOperationsInput
  exitCode: NullableIntFieldUpdateOperationsInput
  jobRunId: NullableIntFieldUpdateOperationsInput
  moreInfo: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  status: EnumJobStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobRunUpdateManyWithoutJobInput {
  connect: [JobRunWhereUniqueInput!]
  create: [JobRunCreateWithoutJobInput!]
  delete: [JobRunWhereUniqueInput!]
  deleteMany: [JobRunScalarWhereInput!]
  disconnect: [JobRunWhereUniqueInput!]
  set: [JobRunWhereUniqueInput!]
  update: [JobRunUpdateWithWhereUniqueWithoutJobInput!]
  updateMany: [JobRunUpdateManyWithWhereNestedInput!]
  upsert: [JobRunUpsertWithWhereUniqueWithoutJobInput!]
}

input JobRunUpdateManyWithWhereNestedInput {
  data: JobRunUpdateManyDataInput!
  where: JobRunScalarWhereInput!
}

input JobRunUpdateWithoutJobDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: NullableDateTimeFieldUpdateOperationsInput
  exitCode: NullableIntFieldUpdateOperationsInput
  jobRunId: NullableIntFieldUpdateOperationsInput
  moreInfo: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  status: EnumJobStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobRunUpdateWithWhereUniqueWithoutJobInput {
  data: JobRunUpdateWithoutJobDataInput!
  where: JobRunWhereUniqueInput!
}

input JobRunUpsertWithWhereUniqueWithoutJobInput {
  create: JobRunCreateWithoutJobInput!
  update: JobRunUpdateWithoutJobDataInput!
  where: JobRunWhereUniqueInput!
}

input JobRunWhereInput {
  AND: [JobRunWhereInput!]
  createdAt: DateTimeFilter
  endTime: DateTimeNullableFilter
  exitCode: IntNullableFilter
  id: IntFilter
  job: JobWhereInput
  jobId: IntFilter
  jobRunId: IntNullableFilter
  moreInfo: StringNullableFilter
  NOT: [JobRunWhereInput!]
  OR: [JobRunWhereInput!]
  startTime: DateTimeFilter
  status: EnumJobStatusFilter
  updatedAt: DateTimeFilter
}

input JobRunWhereUniqueInput {
  id: Int
  jobId_startTime: JobIdStartTimeCompoundUniqueInput
}

enum JobStatus {
  ACTIVATED
  FAILURE
  INACTIVE
  ON_HOLD
  ON_ICE
  ON_NOEXEC
  PEND_MACH
  QUE_WAIT
  RESTART
  RESWAIT
  RUNNING
  STARTING
  SUCCESS
  TERMINATED
  WAIT_REPLY
}

type JobSumAggregateOutputType {
  id: Int!
}

enum JobType {
  AUTOSYS
  DATABASE
  FMC
  INSTRUMENTED
}

input JobUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  jobType: NullableEnumJobTypeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  runs: JobRunUpdateManyWithoutJobInput
  Steps: StepUpdateManyWithoutJobInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  jobType: NullableEnumJobTypeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobUpdateOneRequiredWithoutRunsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutRunsInput
  update: JobUpdateWithoutRunsDataInput
  upsert: JobUpsertWithoutRunsInput
}

input JobUpdateOneRequiredWithoutStepsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutStepsInput
  update: JobUpdateWithoutStepsDataInput
  upsert: JobUpsertWithoutStepsInput
}

input JobUpdateWithoutRunsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  jobType: NullableEnumJobTypeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Steps: StepUpdateManyWithoutJobInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobUpdateWithoutStepsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  jobType: NullableEnumJobTypeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  runs: JobRunUpdateManyWithoutJobInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input JobUpsertWithoutRunsInput {
  create: JobCreateWithoutRunsInput!
  update: JobUpdateWithoutRunsDataInput!
}

input JobUpsertWithoutStepsInput {
  create: JobCreateWithoutStepsInput!
  update: JobUpdateWithoutStepsDataInput!
}

input JobWhereInput {
  AND: [JobWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  jobType: EnumJobTypeNullableFilter
  name: StringFilter
  NOT: [JobWhereInput!]
  OR: [JobWhereInput!]
  runs: JobRunListRelationFilter
  Steps: StepListRelationFilter
  updatedAt: DateTimeFilter
}

input JobWhereUniqueInput {
  id: Int
  name: String
}

type JournalEntry {
  author: User!
  authorId: Int!
  createdAt: DateTime!
  entry: String!
  id: Int!
  step: Step!
  stepId: Int!
}

type JournalEntryAvgAggregateOutputType {
  authorId: Float!
  id: Float!
  stepId: Float!
}

input JournalEntryCreateInput {
  author: UserCreateOneWithoutJournalEntriesInput!
  createdAt: DateTime
  entry: String!
  step: StepCreateOneWithoutJournalEntriesInput!
}

input JournalEntryCreateManyWithoutAuthorInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutAuthorInput!]
}

input JournalEntryCreateManyWithoutStepInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutStepInput!]
}

input JournalEntryCreateWithoutAuthorInput {
  createdAt: DateTime
  entry: String!
  step: StepCreateOneWithoutJournalEntriesInput!
}

input JournalEntryCreateWithoutStepInput {
  author: UserCreateOneWithoutJournalEntriesInput!
  createdAt: DateTime
  entry: String!
}

enum JournalEntryDistinctFieldEnum {
  authorId
  createdAt
  entry
  id
  stepId
}

input JournalEntryListRelationFilter {
  every: JournalEntryWhereInput
  none: JournalEntryWhereInput
  some: JournalEntryWhereInput
}

type JournalEntryMaxAggregateOutputType {
  authorId: Int!
  id: Int!
  stepId: Int!
}

type JournalEntryMinAggregateOutputType {
  authorId: Int!
  id: Int!
  stepId: Int!
}

input JournalEntryOrderByInput {
  authorId: SortOrder
  createdAt: SortOrder
  entry: SortOrder
  id: SortOrder
  stepId: SortOrder
}

input JournalEntryScalarWhereInput {
  AND: [JournalEntryScalarWhereInput!]
  authorId: IntFilter
  createdAt: DateTimeFilter
  entry: StringFilter
  id: IntFilter
  NOT: [JournalEntryScalarWhereInput!]
  OR: [JournalEntryScalarWhereInput!]
  stepId: IntFilter
}

type JournalEntrySumAggregateOutputType {
  authorId: Int!
  id: Int!
  stepId: Int!
}

input JournalEntryUpdateInput {
  author: UserUpdateOneRequiredWithoutJournalEntriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: StringFieldUpdateOperationsInput
  step: StepUpdateOneRequiredWithoutJournalEntriesInput
}

input JournalEntryUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: StringFieldUpdateOperationsInput
}

input JournalEntryUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: StringFieldUpdateOperationsInput
}

input JournalEntryUpdateManyWithoutAuthorInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutAuthorInput!]
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [JournalEntryUpdateManyWithWhereNestedInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutAuthorInput!]
}

input JournalEntryUpdateManyWithoutStepInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutStepInput!]
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutStepInput!]
  updateMany: [JournalEntryUpdateManyWithWhereNestedInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutStepInput!]
}

input JournalEntryUpdateManyWithWhereNestedInput {
  data: JournalEntryUpdateManyDataInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateWithoutAuthorDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: StringFieldUpdateOperationsInput
  step: StepUpdateOneRequiredWithoutJournalEntriesInput
}

input JournalEntryUpdateWithoutStepDataInput {
  author: UserUpdateOneRequiredWithoutJournalEntriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: StringFieldUpdateOperationsInput
}

input JournalEntryUpdateWithWhereUniqueWithoutAuthorInput {
  data: JournalEntryUpdateWithoutAuthorDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpdateWithWhereUniqueWithoutStepInput {
  data: JournalEntryUpdateWithoutStepDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpsertWithWhereUniqueWithoutAuthorInput {
  create: JournalEntryCreateWithoutAuthorInput!
  update: JournalEntryUpdateWithoutAuthorDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpsertWithWhereUniqueWithoutStepInput {
  create: JournalEntryCreateWithoutStepInput!
  update: JournalEntryUpdateWithoutStepDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryWhereInput {
  AND: [JournalEntryWhereInput!]
  author: UserWhereInput
  authorId: IntFilter
  createdAt: DateTimeFilter
  entry: StringFilter
  id: IntFilter
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  step: StepWhereInput
  stepId: IntFilter
}

input JournalEntryWhereUniqueInput {
  id: Int
}

"""Json custom scalar type"""
scalar Json

enum KindEnum {
  enum
  object
  scalar
}

type Model {
  create: Boolean!
  delete: Boolean!
  displayFields: [String!]!
  fields: [Field!]!
  id: String!
  idField: String!
  name: String!
  update: Boolean!
}

type Mutation {
  createOneDashboard(data: DashboardCreateInput!): Dashboard!
  createOneGroup(data: GroupCreateInput!): Group!
  createOneJob(data: JobCreateInput!): Job!
  createOneJobRun(data: JobRunCreateInput!): JobRun!
  createOneJournalEntry(data: JournalEntryCreateInput!): JournalEntry!
  createOneSection(data: SectionCreateInput!): Section!
  createOneStep(data: StepCreateInput!): Step!
  createOneUser(data: UserCreateInput!): User!
  deleteOneDashboard(where: DashboardWhereUniqueInput!): Dashboard
  deleteOneGroup(where: GroupWhereUniqueInput!): Group
  deleteOneJob(where: JobWhereUniqueInput!): Job
  deleteOneJobRun(where: JobRunWhereUniqueInput!): JobRun
  deleteOneJournalEntry(where: JournalEntryWhereUniqueInput!): JournalEntry
  deleteOneSection(where: SectionWhereUniqueInput!): Section
  deleteOneStep(where: StepWhereUniqueInput!): Step
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): User
  logout: Boolean!
  signup(email: String!, name: String, password: String!): User!
  updateField(data: UpdateFieldInput, id: String!, modelId: String!): Field!
  updateModel(data: UpdateModelInput, id: String!): Model!
  updateOneDashboard(data: DashboardUpdateInput!, where: DashboardWhereUniqueInput!): Dashboard!
  updateOneGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group!
  updateOneJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job!
  updateOneJobRun(data: JobRunUpdateInput!, where: JobRunWhereUniqueInput!): JobRun!
  updateOneJournalEntry(data: JournalEntryUpdateInput!, where: JournalEntryWhereUniqueInput!): JournalEntry!
  updateOneSection(data: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section!
  updateOneStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  updatePassword(currentPassword: String!, password: String!): Boolean!
  upsertOneDashboard(create: DashboardCreateInput!, update: DashboardUpdateInput!, where: DashboardWhereUniqueInput!): Dashboard!
  upsertOneGroup(create: GroupCreateInput!, update: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group!
  upsertOneJob(create: JobCreateInput!, update: JobUpdateInput!, where: JobWhereUniqueInput!): Job!
  upsertOneJobRun(create: JobRunCreateInput!, update: JobRunUpdateInput!, where: JobRunWhereUniqueInput!): JobRun!
  upsertOneJournalEntry(create: JournalEntryCreateInput!, update: JournalEntryUpdateInput!, where: JournalEntryWhereUniqueInput!): JournalEntry!
  upsertOneSection(create: SectionCreateInput!, update: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section!
  upsertOneStep(create: StepCreateInput!, update: StepUpdateInput!, where: StepWhereUniqueInput!): Step!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumJobStatusFilter {
  equals: JobStatus
  in: [JobStatus!]
  not: NestedEnumJobStatusFilter
  notIn: [JobStatus!]
}

input NestedEnumJobTypeNullableFilter {
  equals: JobType
  in: [JobType!]
  not: NestedEnumJobTypeNullableFilter
  notIn: [JobType!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableEnumJobTypeFieldUpdateOperationsInput {
  set: JobType
}

input NullableIntFieldUpdateOperationsInput {
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  findManyDashboard(cursor: DashboardWhereUniqueInput, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): [Dashboard!]
  findManyDashboardCount(cursor: DashboardWhereUniqueInput, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): Int!
  findManyGroup(cursor: GroupWhereUniqueInput, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): [Group!]
  findManyGroupCount(cursor: GroupWhereUniqueInput, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): Int!
  findManyJob(cursor: JobWhereUniqueInput, orderBy: JobOrderByInput, skip: Int, take: Int, where: JobWhereInput): [Job!]
  findManyJobCount(cursor: JobWhereUniqueInput, orderBy: JobOrderByInput, skip: Int, take: Int, where: JobWhereInput): Int!
  findManyJobRun(cursor: JobRunWhereUniqueInput, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): [JobRun!]
  findManyJobRunCount(cursor: JobRunWhereUniqueInput, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): Int!
  findManyJournalEntry(cursor: JournalEntryWhereUniqueInput, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): [JournalEntry!]
  findManyJournalEntryCount(cursor: JournalEntryWhereUniqueInput, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): Int!
  findManySection(cursor: SectionWhereUniqueInput, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): [Section!]
  findManySectionCount(cursor: SectionWhereUniqueInput, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): Int!
  findManyStep(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]
  findManyStepCount(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User!]
  findManyUserCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int!
  findOneDashboard(where: DashboardWhereUniqueInput!): Dashboard
  findOneGroup(where: GroupWhereUniqueInput!): Group
  findOneJob(where: JobWhereUniqueInput!): Job
  findOneJobRun(where: JobRunWhereUniqueInput!): JobRun
  findOneJournalEntry(where: JournalEntryWhereUniqueInput!): JournalEntry
  findOneSection(where: SectionWhereUniqueInput!): Section
  findOneStep(where: StepWhereUniqueInput!): Step
  findOneUser(where: UserWhereUniqueInput!): User
  getSchema: Schema!
  me: User
}

enum QueryMode {
  default
  insensitive
}

type Schema {
  enums: [Enum!]!
  models: [Model!]!
}

type Section {
  createdAt: DateTime!
  dashboard: Dashboard
  dashboardId: Int
  id: Int!
  name: String!
  order: Int!
  published: Boolean!
  steps(cursor: StepWhereUniqueInput, distinct: StepDistinctFieldEnum, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]!
  successCriteria: String
  updatedAt: DateTime!
}

type SectionAvgAggregateOutputType {
  dashboardId: Float!
  id: Float!
  order: Float!
}

input SectionCreateInput {
  createdAt: DateTime
  dashboard: DashboardCreateOneWithoutSectionsInput
  name: String!
  order: Int
  published: Boolean
  steps: StepCreateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionCreateManyWithoutDashboardInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutDashboardInput!]
}

input SectionCreateOneWithoutStepsInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutStepsInput
}

input SectionCreateWithoutDashboardInput {
  createdAt: DateTime
  name: String!
  order: Int
  published: Boolean
  steps: StepCreateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionCreateWithoutStepsInput {
  createdAt: DateTime
  dashboard: DashboardCreateOneWithoutSectionsInput
  name: String!
  order: Int
  published: Boolean
  successCriteria: String
  updatedAt: DateTime
}

enum SectionDistinctFieldEnum {
  createdAt
  dashboardId
  id
  name
  order
  published
  successCriteria
  updatedAt
}

input SectionListRelationFilter {
  every: SectionWhereInput
  none: SectionWhereInput
  some: SectionWhereInput
}

type SectionMaxAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

type SectionMinAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

input SectionOrderByInput {
  createdAt: SortOrder
  dashboardId: SortOrder
  id: SortOrder
  name: SortOrder
  order: SortOrder
  published: SortOrder
  successCriteria: SortOrder
  updatedAt: SortOrder
}

input SectionRelationFilter {
  is: SectionWhereInput
  isNot: SectionWhereInput
}

input SectionScalarWhereInput {
  AND: [SectionScalarWhereInput!]
  createdAt: DateTimeFilter
  dashboardId: IntNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [SectionScalarWhereInput!]
  OR: [SectionScalarWhereInput!]
  order: IntFilter
  published: BoolFilter
  successCriteria: StringNullableFilter
  updatedAt: DateTimeFilter
}

type SectionSumAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

input SectionUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dashboard: DashboardUpdateOneWithoutSectionsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  steps: StepUpdateManyWithoutSectionInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SectionUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SectionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SectionUpdateManyWithoutDashboardInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutDashboardInput!]
  delete: [SectionWhereUniqueInput!]
  deleteMany: [SectionScalarWhereInput!]
  disconnect: [SectionWhereUniqueInput!]
  set: [SectionWhereUniqueInput!]
  update: [SectionUpdateWithWhereUniqueWithoutDashboardInput!]
  updateMany: [SectionUpdateManyWithWhereNestedInput!]
  upsert: [SectionUpsertWithWhereUniqueWithoutDashboardInput!]
}

input SectionUpdateManyWithWhereNestedInput {
  data: SectionUpdateManyDataInput!
  where: SectionScalarWhereInput!
}

input SectionUpdateOneRequiredWithoutStepsInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutStepsInput
  update: SectionUpdateWithoutStepsDataInput
  upsert: SectionUpsertWithoutStepsInput
}

input SectionUpdateWithoutDashboardDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  steps: StepUpdateManyWithoutSectionInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SectionUpdateWithoutStepsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dashboard: DashboardUpdateOneWithoutSectionsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SectionUpdateWithWhereUniqueWithoutDashboardInput {
  data: SectionUpdateWithoutDashboardDataInput!
  where: SectionWhereUniqueInput!
}

input SectionUpsertWithoutStepsInput {
  create: SectionCreateWithoutStepsInput!
  update: SectionUpdateWithoutStepsDataInput!
}

input SectionUpsertWithWhereUniqueWithoutDashboardInput {
  create: SectionCreateWithoutDashboardInput!
  update: SectionUpdateWithoutDashboardDataInput!
  where: SectionWhereUniqueInput!
}

input SectionWhereInput {
  AND: [SectionWhereInput!]
  createdAt: DateTimeFilter
  dashboard: DashboardWhereInput
  dashboardId: IntNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [SectionWhereInput!]
  OR: [SectionWhereInput!]
  order: IntFilter
  published: BoolFilter
  steps: StepListRelationFilter
  successCriteria: StringNullableFilter
  updatedAt: DateTimeFilter
}

input SectionWhereUniqueInput {
  id: Int
  name: String
}

enum SortOrder {
  asc
  desc
}

type Step {
  createdAt: DateTime!
  id: Int!
  job: Job!
  jobId: Int!
  journalEntries(cursor: JournalEntryWhereUniqueInput, distinct: JournalEntryDistinctFieldEnum, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): [JournalEntry!]!
  name: String!
  order: Int!
  section: Section!
  sectionId: Int!
  successCriteria: String
  updatedAt: DateTime!
}

type StepAvgAggregateOutputType {
  id: Float!
  jobId: Float!
  order: Float!
  sectionId: Float!
}

input StepCreateInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepsInput!
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateManyWithoutJobInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutJobInput!]
}

input StepCreateManyWithoutSectionInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutSectionInput!]
}

input StepCreateOneWithoutJournalEntriesInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutJournalEntriesInput
}

input StepCreateWithoutJobInput {
  createdAt: DateTime
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateWithoutJournalEntriesInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepsInput!
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateWithoutSectionInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepsInput!
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  successCriteria: String
  updatedAt: DateTime
}

enum StepDistinctFieldEnum {
  createdAt
  id
  jobId
  name
  order
  sectionId
  successCriteria
  updatedAt
}

input StepListRelationFilter {
  every: StepWhereInput
  none: StepWhereInput
  some: StepWhereInput
}

type StepMaxAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

type StepMinAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

input StepOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  name: SortOrder
  order: SortOrder
  sectionId: SortOrder
  successCriteria: SortOrder
  updatedAt: SortOrder
}

input StepRelationFilter {
  is: StepWhereInput
  isNot: StepWhereInput
}

input StepScalarWhereInput {
  AND: [StepScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  jobId: IntFilter
  name: StringFilter
  NOT: [StepScalarWhereInput!]
  OR: [StepScalarWhereInput!]
  order: IntFilter
  sectionId: IntFilter
  successCriteria: StringNullableFilter
  updatedAt: DateTimeFilter
}

type StepSumAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

input StepUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  job: JobUpdateOneRequiredWithoutStepsInput
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateManyWithoutJobInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutJobInput!]
  delete: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  disconnect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  update: [StepUpdateWithWhereUniqueWithoutJobInput!]
  updateMany: [StepUpdateManyWithWhereNestedInput!]
  upsert: [StepUpsertWithWhereUniqueWithoutJobInput!]
}

input StepUpdateManyWithoutSectionInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutSectionInput!]
  delete: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  disconnect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  update: [StepUpdateWithWhereUniqueWithoutSectionInput!]
  updateMany: [StepUpdateManyWithWhereNestedInput!]
  upsert: [StepUpsertWithWhereUniqueWithoutSectionInput!]
}

input StepUpdateManyWithWhereNestedInput {
  data: StepUpdateManyDataInput!
  where: StepScalarWhereInput!
}

input StepUpdateOneRequiredWithoutJournalEntriesInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutJournalEntriesInput
  update: StepUpdateWithoutJournalEntriesDataInput
  upsert: StepUpsertWithoutJournalEntriesInput
}

input StepUpdateWithoutJobDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateWithoutJournalEntriesDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  job: JobUpdateOneRequiredWithoutStepsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateWithoutSectionDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  job: JobUpdateOneRequiredWithoutStepsInput
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  successCriteria: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StepUpdateWithWhereUniqueWithoutJobInput {
  data: StepUpdateWithoutJobDataInput!
  where: StepWhereUniqueInput!
}

input StepUpdateWithWhereUniqueWithoutSectionInput {
  data: StepUpdateWithoutSectionDataInput!
  where: StepWhereUniqueInput!
}

input StepUpsertWithoutJournalEntriesInput {
  create: StepCreateWithoutJournalEntriesInput!
  update: StepUpdateWithoutJournalEntriesDataInput!
}

input StepUpsertWithWhereUniqueWithoutJobInput {
  create: StepCreateWithoutJobInput!
  update: StepUpdateWithoutJobDataInput!
  where: StepWhereUniqueInput!
}

input StepUpsertWithWhereUniqueWithoutSectionInput {
  create: StepCreateWithoutSectionInput!
  update: StepUpdateWithoutSectionDataInput!
  where: StepWhereUniqueInput!
}

input StepWhereInput {
  AND: [StepWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  job: JobWhereInput
  jobId: IntFilter
  journalEntries: JournalEntryListRelationFilter
  name: StringFilter
  NOT: [StepWhereInput!]
  OR: [StepWhereInput!]
  order: IntFilter
  section: SectionWhereInput
  sectionId: IntFilter
  successCriteria: StringNullableFilter
  updatedAt: DateTimeFilter
}

input StepWhereUniqueInput {
  id: Int
  name: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input UpdateFieldInput {
  create: Boolean
  editor: Boolean
  filter: Boolean
  id: String
  isId: Boolean
  kind: KindEnum
  list: Boolean
  name: String
  order: Int
  read: Boolean
  relationField: Boolean
  required: Boolean
  sort: Boolean
  title: String
  type: String
  unique: Boolean
  update: Boolean
  upload: Boolean
}

input UpdateModelInput {
  create: Boolean
  delete: Boolean
  displayFields: [String!]
  fields: [UpdateFieldInput!]
  idField: String
  name: String
  update: Boolean
}

type User {
  createdAt: DateTime!
  email: String!
  group: Group
  groupId: Int
  id: Int!
  isAdmin: Boolean!
  JournalEntries(cursor: JournalEntryWhereUniqueInput, distinct: JournalEntryDistinctFieldEnum, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): [JournalEntry!]!
  name: String
  password: String!
}

type UserAvgAggregateOutputType {
  groupId: Float!
  id: Float!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  group: GroupCreateOneWithoutUsersInput
  isAdmin: Boolean
  JournalEntries: JournalEntryCreateManyWithoutAuthorInput
  name: String
  password: String!
}

input UserCreateManyWithoutGroupInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutGroupInput!]
}

input UserCreateOneWithoutJournalEntriesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutJournalEntriesInput
}

input UserCreateWithoutGroupInput {
  createdAt: DateTime
  email: String!
  isAdmin: Boolean
  JournalEntries: JournalEntryCreateManyWithoutAuthorInput
  name: String
  password: String!
}

input UserCreateWithoutJournalEntriesInput {
  createdAt: DateTime
  email: String!
  group: GroupCreateOneWithoutUsersInput
  isAdmin: Boolean
  name: String
  password: String!
}

enum UserDistinctFieldEnum {
  createdAt
  email
  groupId
  id
  isAdmin
  name
  password
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregateOutputType {
  groupId: Int!
  id: Int!
}

type UserMinAggregateOutputType {
  groupId: Int!
  id: Int!
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  groupId: IntNullableFilter
  id: IntFilter
  isAdmin: BoolFilter
  name: StringNullableFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
}

type UserSumAggregateOutputType {
  groupId: Int!
  id: Int!
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  group: GroupUpdateOneWithoutUsersInput
  isAdmin: BoolFieldUpdateOperationsInput
  JournalEntries: JournalEntryUpdateManyWithoutAuthorInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithoutGroupInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutGroupInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutGroupInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutJournalEntriesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutJournalEntriesInput
  update: UserUpdateWithoutJournalEntriesDataInput
  upsert: UserUpsertWithoutJournalEntriesInput
}

input UserUpdateWithoutGroupDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  JournalEntries: JournalEntryUpdateManyWithoutAuthorInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutJournalEntriesDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  group: GroupUpdateOneWithoutUsersInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateWithWhereUniqueWithoutGroupInput {
  data: UserUpdateWithoutGroupDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutJournalEntriesInput {
  create: UserCreateWithoutJournalEntriesInput!
  update: UserUpdateWithoutJournalEntriesDataInput!
}

input UserUpsertWithWhereUniqueWithoutGroupInput {
  create: UserCreateWithoutGroupInput!
  update: UserUpdateWithoutGroupDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  group: GroupWhereInput
  groupId: IntNullableFilter
  id: IntFilter
  isAdmin: BoolFilter
  JournalEntries: JournalEntryListRelationFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
