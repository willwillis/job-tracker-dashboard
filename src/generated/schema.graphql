### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateDashboard {
  avg: DashboardAvgAggregateOutputType!
  count: Int!
  max: DashboardMaxAggregateOutputType!
  min: DashboardMinAggregateOutputType!
  sum: DashboardSumAggregateOutputType!
}

type AggregateGroup {
  avg: GroupAvgAggregateOutputType!
  count: Int!
  max: GroupMaxAggregateOutputType!
  min: GroupMinAggregateOutputType!
  sum: GroupSumAggregateOutputType!
}

type AggregateJob {
  avg: JobAvgAggregateOutputType!
  count: Int!
  max: JobMaxAggregateOutputType!
  min: JobMinAggregateOutputType!
  sum: JobSumAggregateOutputType!
}

type AggregateJobRun {
  avg: JobRunAvgAggregateOutputType!
  count: Int!
  max: JobRunMaxAggregateOutputType!
  min: JobRunMinAggregateOutputType!
  sum: JobRunSumAggregateOutputType!
}

type AggregateJournalEntry {
  avg: JournalEntryAvgAggregateOutputType!
  count: Int!
  max: JournalEntryMaxAggregateOutputType!
  min: JournalEntryMinAggregateOutputType!
  sum: JournalEntrySumAggregateOutputType!
}

type AggregateSection {
  avg: SectionAvgAggregateOutputType!
  count: Int!
  max: SectionMaxAggregateOutputType!
  min: SectionMinAggregateOutputType!
  sum: SectionSumAggregateOutputType!
}

type AggregateStep {
  avg: StepAvgAggregateOutputType!
  count: Int!
  max: StepMaxAggregateOutputType!
  min: StepMinAggregateOutputType!
  sum: StepSumAggregateOutputType!
}

type AggregateUser {
  avg: UserAvgAggregateOutputType!
  count: Int!
  max: UserMaxAggregateOutputType!
  min: UserMinAggregateOutputType!
  sum: UserSumAggregateOutputType!
}

type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Dashboard {
  createdAt: DateTime!
  groups(cursor: GroupWhereUniqueInput, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): [Group!]!
  id: Int!
  name: String!
  published: Boolean!
  sections(cursor: SectionWhereUniqueInput, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): [Section!]!
  updatedAt: DateTime!
}

type DashboardAvgAggregateOutputType {
  id: Float!
  minuteOffset: Float!
}

input DashboardCreateInput {
  createdAt: DateTime
  groups: GroupCreateManyWithoutDashboardsInput
  minuteOffset: Int
  name: String!
  published: Boolean
  sections: SectionCreateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardCreateManyWithoutGroupsInput {
  connect: [DashboardWhereUniqueInput!]
  create: [DashboardCreateWithoutGroupsInput!]
}

input DashboardCreateOneWithoutSectionsInput {
  connect: DashboardWhereUniqueInput
  create: DashboardCreateWithoutSectionsInput
}

input DashboardCreateWithoutGroupsInput {
  createdAt: DateTime
  minuteOffset: Int
  name: String!
  published: Boolean
  sections: SectionCreateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardCreateWithoutSectionsInput {
  createdAt: DateTime
  groups: GroupCreateManyWithoutDashboardsInput
  minuteOffset: Int
  name: String!
  published: Boolean
  updatedAt: DateTime
}

input DashboardFilter {
  every: DashboardWhereInput
  none: DashboardWhereInput
  some: DashboardWhereInput
}

type DashboardMaxAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

type DashboardMinAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

input DashboardOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  minuteOffset: OrderByArg
  name: OrderByArg
  published: OrderByArg
  updatedAt: OrderByArg
}

input DashboardScalarWhereInput {
  AND: [DashboardScalarWhereInput!]
  createdAt: DateTimeFilter
  groups: GroupFilter
  id: IntFilter
  minuteOffset: IntFilter
  name: StringFilter
  NOT: [DashboardScalarWhereInput!]
  OR: [DashboardScalarWhereInput!]
  published: BooleanFilter
  sections: SectionFilter
  updatedAt: DateTimeFilter
}

type DashboardSumAggregateOutputType {
  id: Int!
  minuteOffset: Int!
}

input DashboardUpdateInput {
  createdAt: DateTime
  groups: GroupUpdateManyWithoutDashboardsInput
  id: Int
  minuteOffset: Int
  name: String
  published: Boolean
  sections: SectionUpdateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  minuteOffset: Int
  name: String
  published: Boolean
  updatedAt: DateTime
}

input DashboardUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  minuteOffset: Int
  name: String
  published: Boolean
  updatedAt: DateTime
}

input DashboardUpdateManyWithoutGroupsInput {
  connect: [DashboardWhereUniqueInput!]
  create: [DashboardCreateWithoutGroupsInput!]
  delete: [DashboardWhereUniqueInput!]
  deleteMany: [DashboardScalarWhereInput!]
  disconnect: [DashboardWhereUniqueInput!]
  set: [DashboardWhereUniqueInput!]
  update: [DashboardUpdateWithWhereUniqueWithoutGroupsInput!]
  updateMany: [DashboardUpdateManyWithWhereNestedInput!]
  upsert: [DashboardUpsertWithWhereUniqueWithoutGroupsInput!]
}

input DashboardUpdateManyWithWhereNestedInput {
  data: DashboardUpdateManyDataInput!
  where: DashboardScalarWhereInput!
}

input DashboardUpdateOneWithoutSectionsInput {
  connect: DashboardWhereUniqueInput
  create: DashboardCreateWithoutSectionsInput
  delete: Boolean
  disconnect: Boolean
  update: DashboardUpdateWithoutSectionsDataInput
  upsert: DashboardUpsertWithoutSectionsInput
}

input DashboardUpdateWithoutGroupsDataInput {
  createdAt: DateTime
  id: Int
  minuteOffset: Int
  name: String
  published: Boolean
  sections: SectionUpdateManyWithoutDashboardInput
  updatedAt: DateTime
}

input DashboardUpdateWithoutSectionsDataInput {
  createdAt: DateTime
  groups: GroupUpdateManyWithoutDashboardsInput
  id: Int
  minuteOffset: Int
  name: String
  published: Boolean
  updatedAt: DateTime
}

input DashboardUpdateWithWhereUniqueWithoutGroupsInput {
  data: DashboardUpdateWithoutGroupsDataInput!
  where: DashboardWhereUniqueInput!
}

input DashboardUpsertWithoutSectionsInput {
  create: DashboardCreateWithoutSectionsInput!
  update: DashboardUpdateWithoutSectionsDataInput!
}

input DashboardUpsertWithWhereUniqueWithoutGroupsInput {
  create: DashboardCreateWithoutGroupsInput!
  update: DashboardUpdateWithoutGroupsDataInput!
  where: DashboardWhereUniqueInput!
}

input DashboardWhereInput {
  AND: [DashboardWhereInput!]
  createdAt: DateTimeFilter
  groups: GroupFilter
  id: IntFilter
  minuteOffset: IntFilter
  name: StringFilter
  NOT: [DashboardWhereInput!]
  OR: [DashboardWhereInput!]
  published: BooleanFilter
  sections: SectionFilter
  updatedAt: DateTimeFilter
}

input DashboardWhereUniqueInput {
  id: Int
  name: String
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Enum {
  fields: [String!]!
  name: String!
}

type Field {
  create: Boolean!
  editor: Boolean!
  filter: Boolean!
  id: String!
  isId: Boolean!
  kind: KindEnum!
  list: Boolean!
  name: String!
  order: Int!
  read: Boolean!
  relationField: Boolean
  required: Boolean!
  sort: Boolean!
  title: String!
  type: String!
  unique: Boolean!
  update: Boolean!
  upload: Boolean!
}

type Group {
  createdAt: DateTime!
  dashboards(cursor: DashboardWhereUniqueInput, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): [Dashboard!]!
  id: Int!
  name: String!
  updatedAt: DateTime!
  users(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type GroupAvgAggregateOutputType {
  id: Float!
}

input GroupCreateInput {
  createdAt: DateTime
  dashboards: DashboardCreateManyWithoutGroupsInput
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutGroupInput
}

input GroupCreateManyWithoutDashboardsInput {
  connect: [GroupWhereUniqueInput!]
  create: [GroupCreateWithoutDashboardsInput!]
}

input GroupCreateOneWithoutUsersInput {
  connect: GroupWhereUniqueInput
  create: GroupCreateWithoutUsersInput
}

input GroupCreateWithoutDashboardsInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutGroupInput
}

input GroupCreateWithoutUsersInput {
  createdAt: DateTime
  dashboards: DashboardCreateManyWithoutGroupsInput
  name: String!
  updatedAt: DateTime
}

input GroupFilter {
  every: GroupWhereInput
  none: GroupWhereInput
  some: GroupWhereInput
}

type GroupMaxAggregateOutputType {
  id: Int!
}

type GroupMinAggregateOutputType {
  id: Int!
}

input GroupOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
}

input GroupScalarWhereInput {
  AND: [GroupScalarWhereInput!]
  createdAt: DateTimeFilter
  dashboards: DashboardFilter
  id: IntFilter
  name: StringFilter
  NOT: [GroupScalarWhereInput!]
  OR: [GroupScalarWhereInput!]
  updatedAt: DateTimeFilter
  users: UserFilter
}

type GroupSumAggregateOutputType {
  id: Int!
}

input GroupUpdateInput {
  createdAt: DateTime
  dashboards: DashboardUpdateManyWithoutGroupsInput
  id: Int
  name: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutGroupInput
}

input GroupUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GroupUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GroupUpdateManyWithoutDashboardsInput {
  connect: [GroupWhereUniqueInput!]
  create: [GroupCreateWithoutDashboardsInput!]
  delete: [GroupWhereUniqueInput!]
  deleteMany: [GroupScalarWhereInput!]
  disconnect: [GroupWhereUniqueInput!]
  set: [GroupWhereUniqueInput!]
  update: [GroupUpdateWithWhereUniqueWithoutDashboardsInput!]
  updateMany: [GroupUpdateManyWithWhereNestedInput!]
  upsert: [GroupUpsertWithWhereUniqueWithoutDashboardsInput!]
}

input GroupUpdateManyWithWhereNestedInput {
  data: GroupUpdateManyDataInput!
  where: GroupScalarWhereInput!
}

input GroupUpdateOneWithoutUsersInput {
  connect: GroupWhereUniqueInput
  create: GroupCreateWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  update: GroupUpdateWithoutUsersDataInput
  upsert: GroupUpsertWithoutUsersInput
}

input GroupUpdateWithoutDashboardsDataInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutGroupInput
}

input GroupUpdateWithoutUsersDataInput {
  createdAt: DateTime
  dashboards: DashboardUpdateManyWithoutGroupsInput
  id: Int
  name: String
  updatedAt: DateTime
}

input GroupUpdateWithWhereUniqueWithoutDashboardsInput {
  data: GroupUpdateWithoutDashboardsDataInput!
  where: GroupWhereUniqueInput!
}

input GroupUpsertWithoutUsersInput {
  create: GroupCreateWithoutUsersInput!
  update: GroupUpdateWithoutUsersDataInput!
}

input GroupUpsertWithWhereUniqueWithoutDashboardsInput {
  create: GroupCreateWithoutDashboardsInput!
  update: GroupUpdateWithoutDashboardsDataInput!
  where: GroupWhereUniqueInput!
}

input GroupWhereInput {
  AND: [GroupWhereInput!]
  createdAt: DateTimeFilter
  dashboards: DashboardFilter
  id: IntFilter
  name: StringFilter
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  updatedAt: DateTimeFilter
  users: UserFilter
}

input GroupWhereUniqueInput {
  id: Int
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Job {
  createdAt: DateTime!
  id: Int!
  jobType: JobType
  joid: Int
  name: String!
  runs(cursor: JobRunWhereUniqueInput, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): [JobRun!]!
  Step(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]!
  updatedAt: DateTime!
}

type JobAvgAggregateOutputType {
  id: Float!
  joid: Float!
}

input JobCreateInput {
  createdAt: DateTime
  jobType: JobType
  joid: Int
  name: String!
  runs: JobRunCreateManyWithoutJobInput
  Step: StepCreateManyWithoutJobInput
  updatedAt: DateTime
}

input JobCreateOneWithoutRunsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutRunsInput
}

input JobCreateOneWithoutStepInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutStepInput
}

input JobCreateWithoutRunsInput {
  createdAt: DateTime
  jobType: JobType
  joid: Int
  name: String!
  Step: StepCreateManyWithoutJobInput
  updatedAt: DateTime
}

input JobCreateWithoutStepInput {
  createdAt: DateTime
  jobType: JobType
  joid: Int
  name: String!
  runs: JobRunCreateManyWithoutJobInput
  updatedAt: DateTime
}

type JobMaxAggregateOutputType {
  id: Int!
  joid: Int!
}

type JobMinAggregateOutputType {
  id: Int!
  joid: Int!
}

input JobOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  jobType: OrderByArg
  joid: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
}

type JobRun {
  createdAt: DateTime!
  endTime: DateTime
  exitCode: Int
  id: Int!
  job: Job!
  jobId: Int!
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus
  updatedAt: DateTime!
}

type JobRunAvgAggregateOutputType {
  exitCode: Float!
  id: Float!
  jobId: Float!
  jobRunId: Float!
  joid: Float!
}

input JobRunCreateInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  job: JobCreateOneWithoutRunsInput!
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus
  updatedAt: DateTime
}

input JobRunCreateManyWithoutJobInput {
  connect: [JobRunWhereUniqueInput!]
  create: [JobRunCreateWithoutJobInput!]
}

input JobRunCreateWithoutJobInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime!
  status: JobStatus
  updatedAt: DateTime
}

input JobRunFilter {
  every: JobRunWhereInput
  none: JobRunWhereInput
  some: JobRunWhereInput
}

type JobRunMaxAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
  joid: Int!
}

type JobRunMinAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
  joid: Int!
}

input JobRunOrderByInput {
  createdAt: OrderByArg
  endTime: OrderByArg
  exitCode: OrderByArg
  id: OrderByArg
  jobId: OrderByArg
  jobRunId: OrderByArg
  joid: OrderByArg
  moreInfo: OrderByArg
  startTime: OrderByArg
  status: OrderByArg
  updatedAt: OrderByArg
}

input JobRunScalarWhereInput {
  AND: [JobRunScalarWhereInput!]
  createdAt: DateTimeFilter
  endTime: NullableDateTimeFilter
  exitCode: NullableIntFilter
  id: IntFilter
  jobId: IntFilter
  jobRunId: NullableIntFilter
  joid: NullableIntFilter
  moreInfo: NullableStringFilter
  NOT: [JobRunScalarWhereInput!]
  OR: [JobRunScalarWhereInput!]
  startTime: DateTimeFilter
  status: NullableJobStatusFilter
  updatedAt: DateTimeFilter
}

type JobRunSumAggregateOutputType {
  exitCode: Int!
  id: Int!
  jobId: Int!
  jobRunId: Int!
  joid: Int!
}

input JobRunUpdateInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  id: Int
  job: JobUpdateOneRequiredWithoutRunsInput
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime
  status: JobStatus
  updatedAt: DateTime
}

input JobRunUpdateManyDataInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  id: Int
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime
  status: JobStatus
  updatedAt: DateTime
}

input JobRunUpdateManyMutationInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  id: Int
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime
  status: JobStatus
  updatedAt: DateTime
}

input JobRunUpdateManyWithoutJobInput {
  connect: [JobRunWhereUniqueInput!]
  create: [JobRunCreateWithoutJobInput!]
  delete: [JobRunWhereUniqueInput!]
  deleteMany: [JobRunScalarWhereInput!]
  disconnect: [JobRunWhereUniqueInput!]
  set: [JobRunWhereUniqueInput!]
  update: [JobRunUpdateWithWhereUniqueWithoutJobInput!]
  updateMany: [JobRunUpdateManyWithWhereNestedInput!]
  upsert: [JobRunUpsertWithWhereUniqueWithoutJobInput!]
}

input JobRunUpdateManyWithWhereNestedInput {
  data: JobRunUpdateManyDataInput!
  where: JobRunScalarWhereInput!
}

input JobRunUpdateWithoutJobDataInput {
  createdAt: DateTime
  endTime: DateTime
  exitCode: Int
  id: Int
  jobRunId: Int
  joid: Int
  moreInfo: String
  startTime: DateTime
  status: JobStatus
  updatedAt: DateTime
}

input JobRunUpdateWithWhereUniqueWithoutJobInput {
  data: JobRunUpdateWithoutJobDataInput!
  where: JobRunWhereUniqueInput!
}

input JobRunUpsertWithWhereUniqueWithoutJobInput {
  create: JobRunCreateWithoutJobInput!
  update: JobRunUpdateWithoutJobDataInput!
  where: JobRunWhereUniqueInput!
}

input JobRunWhereInput {
  AND: [JobRunWhereInput!]
  createdAt: DateTimeFilter
  endTime: NullableDateTimeFilter
  exitCode: NullableIntFilter
  id: IntFilter
  job: JobWhereInput
  jobId: IntFilter
  jobRunId: NullableIntFilter
  joid: NullableIntFilter
  moreInfo: NullableStringFilter
  NOT: [JobRunWhereInput!]
  OR: [JobRunWhereInput!]
  startTime: DateTimeFilter
  status: NullableJobStatusFilter
  updatedAt: DateTimeFilter
}

input JobRunWhereUniqueInput {
  id: Int
}

enum JobStatus {
  ACTIVATED
  FAILURE
  INACTIVE
  ON_HOLD
  ON_ICE
  ON_NOEXEC
  PEND_MACH
  QUE_WAIT
  RESTART
  RESWAIT
  RUNNING
  STARTING
  SUCCESS
  TERMINATED
  WAIT_REPLY
}

type JobSumAggregateOutputType {
  id: Int!
  joid: Int!
}

enum JobType {
  AUTOSYS
  DATABASE
  FMC
  INSTRUMENTED
}

input JobUpdateInput {
  createdAt: DateTime
  id: Int
  jobType: JobType
  joid: Int
  name: String
  runs: JobRunUpdateManyWithoutJobInput
  Step: StepUpdateManyWithoutJobInput
  updatedAt: DateTime
}

input JobUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  jobType: JobType
  joid: Int
  name: String
  updatedAt: DateTime
}

input JobUpdateOneRequiredWithoutRunsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutRunsInput
  update: JobUpdateWithoutRunsDataInput
  upsert: JobUpsertWithoutRunsInput
}

input JobUpdateOneRequiredWithoutStepInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutStepInput
  update: JobUpdateWithoutStepDataInput
  upsert: JobUpsertWithoutStepInput
}

input JobUpdateWithoutRunsDataInput {
  createdAt: DateTime
  id: Int
  jobType: JobType
  joid: Int
  name: String
  Step: StepUpdateManyWithoutJobInput
  updatedAt: DateTime
}

input JobUpdateWithoutStepDataInput {
  createdAt: DateTime
  id: Int
  jobType: JobType
  joid: Int
  name: String
  runs: JobRunUpdateManyWithoutJobInput
  updatedAt: DateTime
}

input JobUpsertWithoutRunsInput {
  create: JobCreateWithoutRunsInput!
  update: JobUpdateWithoutRunsDataInput!
}

input JobUpsertWithoutStepInput {
  create: JobCreateWithoutStepInput!
  update: JobUpdateWithoutStepDataInput!
}

input JobWhereInput {
  AND: [JobWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  jobType: NullableJobTypeFilter
  joid: NullableIntFilter
  name: StringFilter
  NOT: [JobWhereInput!]
  OR: [JobWhereInput!]
  runs: JobRunFilter
  Step: StepFilter
  updatedAt: DateTimeFilter
}

input JobWhereUniqueInput {
  id: Int
  joid: Int
  name: String
}

type JournalEntry {
  entry: String
  id: Int!
  step: Step!
  stepId: Int!
}

type JournalEntryAvgAggregateOutputType {
  id: Float!
  stepId: Float!
}

input JournalEntryCreateInput {
  entry: String
  step: StepCreateOneWithoutJournalEntriesInput!
}

input JournalEntryCreateManyWithoutStepInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutStepInput!]
}

input JournalEntryCreateWithoutStepInput {
  entry: String
}

input JournalEntryFilter {
  every: JournalEntryWhereInput
  none: JournalEntryWhereInput
  some: JournalEntryWhereInput
}

type JournalEntryMaxAggregateOutputType {
  id: Int!
  stepId: Int!
}

type JournalEntryMinAggregateOutputType {
  id: Int!
  stepId: Int!
}

input JournalEntryOrderByInput {
  entry: OrderByArg
  id: OrderByArg
  stepId: OrderByArg
}

input JournalEntryScalarWhereInput {
  AND: [JournalEntryScalarWhereInput!]
  entry: NullableStringFilter
  id: IntFilter
  NOT: [JournalEntryScalarWhereInput!]
  OR: [JournalEntryScalarWhereInput!]
  stepId: IntFilter
}

type JournalEntrySumAggregateOutputType {
  id: Int!
  stepId: Int!
}

input JournalEntryUpdateInput {
  entry: String
  id: Int
  step: StepUpdateOneRequiredWithoutJournalEntriesInput
}

input JournalEntryUpdateManyDataInput {
  entry: String
  id: Int
}

input JournalEntryUpdateManyMutationInput {
  entry: String
  id: Int
}

input JournalEntryUpdateManyWithoutStepInput {
  connect: [JournalEntryWhereUniqueInput!]
  create: [JournalEntryCreateWithoutStepInput!]
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutStepInput!]
  updateMany: [JournalEntryUpdateManyWithWhereNestedInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutStepInput!]
}

input JournalEntryUpdateManyWithWhereNestedInput {
  data: JournalEntryUpdateManyDataInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateWithoutStepDataInput {
  entry: String
  id: Int
}

input JournalEntryUpdateWithWhereUniqueWithoutStepInput {
  data: JournalEntryUpdateWithoutStepDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpsertWithWhereUniqueWithoutStepInput {
  create: JournalEntryCreateWithoutStepInput!
  update: JournalEntryUpdateWithoutStepDataInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryWhereInput {
  AND: [JournalEntryWhereInput!]
  entry: NullableStringFilter
  id: IntFilter
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  step: StepWhereInput
  stepId: IntFilter
}

input JournalEntryWhereUniqueInput {
  id: Int
}

enum KindEnum {
  enum
  object
  scalar
}

type Model {
  create: Boolean!
  delete: Boolean!
  displayFields: [String!]!
  fields: [Field!]!
  id: String!
  idField: String!
  name: String!
  update: Boolean!
}

type Mutation {
  createOneDashboard(data: DashboardCreateInput!): Dashboard!
  createOneGroup(data: GroupCreateInput!): Group!
  createOneJob(data: JobCreateInput!): Job!
  createOneJobRun(data: JobRunCreateInput!): JobRun!
  createOneJournalEntry(data: JournalEntryCreateInput!): JournalEntry!
  createOneSection(data: SectionCreateInput!): Section!
  createOneStep(data: StepCreateInput!): Step!
  createOneUser(data: UserCreateInput!): User!
  deleteOneDashboard(where: DashboardWhereUniqueInput!): Dashboard
  deleteOneGroup(where: GroupWhereUniqueInput!): Group
  deleteOneJob(where: JobWhereUniqueInput!): Job
  deleteOneJobRun(where: JobRunWhereUniqueInput!): JobRun
  deleteOneJournalEntry(where: JournalEntryWhereUniqueInput!): JournalEntry
  deleteOneSection(where: SectionWhereUniqueInput!): Section
  deleteOneStep(where: StepWhereUniqueInput!): Step
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): User
  logout: Boolean!
  signup(email: String!, name: String, password: String!): User!
  updateField(data: UpdateFieldInput, id: String!, modelId: String!): Field!
  updateModel(data: UpdateModelInput, id: String!): Model!
  updateOneDashboard(data: DashboardUpdateInput!, where: DashboardWhereUniqueInput!): Dashboard!
  updateOneGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group!
  updateOneJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job!
  updateOneJobRun(data: JobRunUpdateInput!, where: JobRunWhereUniqueInput!): JobRun!
  updateOneJournalEntry(data: JournalEntryUpdateInput!, where: JournalEntryWhereUniqueInput!): JournalEntry!
  updateOneSection(data: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section!
  updateOneStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  updatePassword(currentPassword: String!, password: String!): Boolean!
  upsertOneDashboard(create: DashboardCreateInput!, update: DashboardUpdateInput!, where: DashboardWhereUniqueInput!): Dashboard!
  upsertOneGroup(create: GroupCreateInput!, update: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group!
  upsertOneJob(create: JobCreateInput!, update: JobUpdateInput!, where: JobWhereUniqueInput!): Job!
  upsertOneJobRun(create: JobRunCreateInput!, update: JobRunUpdateInput!, where: JobRunWhereUniqueInput!): JobRun!
  upsertOneJournalEntry(create: JournalEntryCreateInput!, update: JournalEntryUpdateInput!, where: JournalEntryWhereUniqueInput!): JournalEntry!
  upsertOneSection(create: SectionCreateInput!, update: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section!
  upsertOneStep(create: StepCreateInput!, update: StepUpdateInput!, where: StepWhereUniqueInput!): Step!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableJobStatusFilter {
  equals: JobStatus
  in: [JobStatus!]
  not: JobStatus
  notIn: [JobStatus!]
}

input NullableJobTypeFilter {
  equals: JobType
  in: [JobType!]
  not: JobType
  notIn: [JobType!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  findManyDashboard(cursor: DashboardWhereUniqueInput, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): [Dashboard!]
  findManyDashboardCount(cursor: DashboardWhereUniqueInput, orderBy: DashboardOrderByInput, skip: Int, take: Int, where: DashboardWhereInput): Int!
  findManyGroup(cursor: GroupWhereUniqueInput, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): [Group!]
  findManyGroupCount(cursor: GroupWhereUniqueInput, orderBy: GroupOrderByInput, skip: Int, take: Int, where: GroupWhereInput): Int!
  findManyJob(cursor: JobWhereUniqueInput, orderBy: JobOrderByInput, skip: Int, take: Int, where: JobWhereInput): [Job!]
  findManyJobCount(cursor: JobWhereUniqueInput, orderBy: JobOrderByInput, skip: Int, take: Int, where: JobWhereInput): Int!
  findManyJobRun(cursor: JobRunWhereUniqueInput, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): [JobRun!]
  findManyJobRunCount(cursor: JobRunWhereUniqueInput, orderBy: JobRunOrderByInput, skip: Int, take: Int, where: JobRunWhereInput): Int!
  findManyJournalEntry(cursor: JournalEntryWhereUniqueInput, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): [JournalEntry!]
  findManyJournalEntryCount(cursor: JournalEntryWhereUniqueInput, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): Int!
  findManySection(cursor: SectionWhereUniqueInput, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): [Section!]
  findManySectionCount(cursor: SectionWhereUniqueInput, orderBy: SectionOrderByInput, skip: Int, take: Int, where: SectionWhereInput): Int!
  findManyStep(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]
  findManyStepCount(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User!]
  findManyUserCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int!
  findOneDashboard(where: DashboardWhereUniqueInput!): Dashboard
  findOneGroup(where: GroupWhereUniqueInput!): Group
  findOneJob(where: JobWhereUniqueInput!): Job
  findOneJobRun(where: JobRunWhereUniqueInput!): JobRun
  findOneJournalEntry(where: JournalEntryWhereUniqueInput!): JournalEntry
  findOneSection(where: SectionWhereUniqueInput!): Section
  findOneStep(where: StepWhereUniqueInput!): Step
  findOneUser(where: UserWhereUniqueInput!): User
  getSchema: Schema!
  me: User
}

type Schema {
  enums: [Enum!]!
  models: [Model!]!
}

type Section {
  createdAt: DateTime!
  dashboard: Dashboard
  dashboardId: Int
  id: Int!
  name: String!
  order: Int
  published: Boolean!
  steps(cursor: StepWhereUniqueInput, orderBy: StepOrderByInput, skip: Int, take: Int, where: StepWhereInput): [Step!]!
  successCriteria: String
  updatedAt: DateTime!
}

type SectionAvgAggregateOutputType {
  dashboardId: Float!
  id: Float!
  order: Float!
}

input SectionCreateInput {
  createdAt: DateTime
  dashboard: DashboardCreateOneWithoutSectionsInput
  name: String!
  order: Int
  published: Boolean
  steps: StepCreateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionCreateManyWithoutDashboardInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutDashboardInput!]
}

input SectionCreateOneWithoutStepsInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutStepsInput
}

input SectionCreateWithoutDashboardInput {
  createdAt: DateTime
  name: String!
  order: Int
  published: Boolean
  steps: StepCreateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionCreateWithoutStepsInput {
  createdAt: DateTime
  dashboard: DashboardCreateOneWithoutSectionsInput
  name: String!
  order: Int
  published: Boolean
  successCriteria: String
  updatedAt: DateTime
}

input SectionFilter {
  every: SectionWhereInput
  none: SectionWhereInput
  some: SectionWhereInput
}

type SectionMaxAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

type SectionMinAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

input SectionOrderByInput {
  createdAt: OrderByArg
  dashboardId: OrderByArg
  id: OrderByArg
  name: OrderByArg
  order: OrderByArg
  published: OrderByArg
  successCriteria: OrderByArg
  updatedAt: OrderByArg
}

input SectionScalarWhereInput {
  AND: [SectionScalarWhereInput!]
  createdAt: DateTimeFilter
  dashboardId: NullableIntFilter
  id: IntFilter
  name: StringFilter
  NOT: [SectionScalarWhereInput!]
  OR: [SectionScalarWhereInput!]
  order: NullableIntFilter
  published: BooleanFilter
  steps: StepFilter
  successCriteria: NullableStringFilter
  updatedAt: DateTimeFilter
}

type SectionSumAggregateOutputType {
  dashboardId: Int!
  id: Int!
  order: Int!
}

input SectionUpdateInput {
  createdAt: DateTime
  dashboard: DashboardUpdateOneWithoutSectionsInput
  id: Int
  name: String
  order: Int
  published: Boolean
  steps: StepUpdateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  name: String
  order: Int
  published: Boolean
  successCriteria: String
  updatedAt: DateTime
}

input SectionUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  name: String
  order: Int
  published: Boolean
  successCriteria: String
  updatedAt: DateTime
}

input SectionUpdateManyWithoutDashboardInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutDashboardInput!]
  delete: [SectionWhereUniqueInput!]
  deleteMany: [SectionScalarWhereInput!]
  disconnect: [SectionWhereUniqueInput!]
  set: [SectionWhereUniqueInput!]
  update: [SectionUpdateWithWhereUniqueWithoutDashboardInput!]
  updateMany: [SectionUpdateManyWithWhereNestedInput!]
  upsert: [SectionUpsertWithWhereUniqueWithoutDashboardInput!]
}

input SectionUpdateManyWithWhereNestedInput {
  data: SectionUpdateManyDataInput!
  where: SectionScalarWhereInput!
}

input SectionUpdateOneRequiredWithoutStepsInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutStepsInput
  update: SectionUpdateWithoutStepsDataInput
  upsert: SectionUpsertWithoutStepsInput
}

input SectionUpdateWithoutDashboardDataInput {
  createdAt: DateTime
  id: Int
  name: String
  order: Int
  published: Boolean
  steps: StepUpdateManyWithoutSectionInput
  successCriteria: String
  updatedAt: DateTime
}

input SectionUpdateWithoutStepsDataInput {
  createdAt: DateTime
  dashboard: DashboardUpdateOneWithoutSectionsInput
  id: Int
  name: String
  order: Int
  published: Boolean
  successCriteria: String
  updatedAt: DateTime
}

input SectionUpdateWithWhereUniqueWithoutDashboardInput {
  data: SectionUpdateWithoutDashboardDataInput!
  where: SectionWhereUniqueInput!
}

input SectionUpsertWithoutStepsInput {
  create: SectionCreateWithoutStepsInput!
  update: SectionUpdateWithoutStepsDataInput!
}

input SectionUpsertWithWhereUniqueWithoutDashboardInput {
  create: SectionCreateWithoutDashboardInput!
  update: SectionUpdateWithoutDashboardDataInput!
  where: SectionWhereUniqueInput!
}

input SectionWhereInput {
  AND: [SectionWhereInput!]
  createdAt: DateTimeFilter
  dashboard: DashboardWhereInput
  dashboardId: NullableIntFilter
  id: IntFilter
  name: StringFilter
  NOT: [SectionWhereInput!]
  OR: [SectionWhereInput!]
  order: NullableIntFilter
  published: BooleanFilter
  steps: StepFilter
  successCriteria: NullableStringFilter
  updatedAt: DateTimeFilter
}

input SectionWhereUniqueInput {
  id: Int
  name: String
}

type Step {
  createdAt: DateTime!
  id: Int!
  job: Job!
  jobId: Int!
  journalEntries(cursor: JournalEntryWhereUniqueInput, orderBy: JournalEntryOrderByInput, skip: Int, take: Int, where: JournalEntryWhereInput): [JournalEntry!]!
  name: String!
  order: Int
  section: Section!
  sectionId: Int!
  successCriteria: String
  updatedAt: DateTime!
}

type StepAvgAggregateOutputType {
  id: Float!
  jobId: Float!
  order: Float!
  sectionId: Float!
}

input StepCreateInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepInput!
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateManyWithoutJobInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutJobInput!]
}

input StepCreateManyWithoutSectionInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutSectionInput!]
}

input StepCreateOneWithoutJournalEntriesInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutJournalEntriesInput
}

input StepCreateWithoutJobInput {
  createdAt: DateTime
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateWithoutJournalEntriesInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepInput!
  name: String!
  order: Int
  section: SectionCreateOneWithoutStepsInput!
  successCriteria: String
  updatedAt: DateTime
}

input StepCreateWithoutSectionInput {
  createdAt: DateTime
  job: JobCreateOneWithoutStepInput!
  journalEntries: JournalEntryCreateManyWithoutStepInput
  name: String!
  order: Int
  successCriteria: String
  updatedAt: DateTime
}

input StepFilter {
  every: StepWhereInput
  none: StepWhereInput
  some: StepWhereInput
}

type StepMaxAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

type StepMinAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

input StepOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  jobId: OrderByArg
  name: OrderByArg
  order: OrderByArg
  sectionId: OrderByArg
  successCriteria: OrderByArg
  updatedAt: OrderByArg
}

input StepScalarWhereInput {
  AND: [StepScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  jobId: IntFilter
  journalEntries: JournalEntryFilter
  name: StringFilter
  NOT: [StepScalarWhereInput!]
  OR: [StepScalarWhereInput!]
  order: NullableIntFilter
  sectionId: IntFilter
  successCriteria: NullableStringFilter
  updatedAt: DateTimeFilter
}

type StepSumAggregateOutputType {
  id: Int!
  jobId: Int!
  order: Int!
  sectionId: Int!
}

input StepUpdateInput {
  createdAt: DateTime
  id: Int
  job: JobUpdateOneRequiredWithoutStepInput
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: String
  order: Int
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  name: String
  order: Int
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  name: String
  order: Int
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateManyWithoutJobInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutJobInput!]
  delete: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  disconnect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  update: [StepUpdateWithWhereUniqueWithoutJobInput!]
  updateMany: [StepUpdateManyWithWhereNestedInput!]
  upsert: [StepUpsertWithWhereUniqueWithoutJobInput!]
}

input StepUpdateManyWithoutSectionInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateWithoutSectionInput!]
  delete: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  disconnect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  update: [StepUpdateWithWhereUniqueWithoutSectionInput!]
  updateMany: [StepUpdateManyWithWhereNestedInput!]
  upsert: [StepUpsertWithWhereUniqueWithoutSectionInput!]
}

input StepUpdateManyWithWhereNestedInput {
  data: StepUpdateManyDataInput!
  where: StepScalarWhereInput!
}

input StepUpdateOneRequiredWithoutJournalEntriesInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutJournalEntriesInput
  update: StepUpdateWithoutJournalEntriesDataInput
  upsert: StepUpsertWithoutJournalEntriesInput
}

input StepUpdateWithoutJobDataInput {
  createdAt: DateTime
  id: Int
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: String
  order: Int
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateWithoutJournalEntriesDataInput {
  createdAt: DateTime
  id: Int
  job: JobUpdateOneRequiredWithoutStepInput
  name: String
  order: Int
  section: SectionUpdateOneRequiredWithoutStepsInput
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateWithoutSectionDataInput {
  createdAt: DateTime
  id: Int
  job: JobUpdateOneRequiredWithoutStepInput
  journalEntries: JournalEntryUpdateManyWithoutStepInput
  name: String
  order: Int
  successCriteria: String
  updatedAt: DateTime
}

input StepUpdateWithWhereUniqueWithoutJobInput {
  data: StepUpdateWithoutJobDataInput!
  where: StepWhereUniqueInput!
}

input StepUpdateWithWhereUniqueWithoutSectionInput {
  data: StepUpdateWithoutSectionDataInput!
  where: StepWhereUniqueInput!
}

input StepUpsertWithoutJournalEntriesInput {
  create: StepCreateWithoutJournalEntriesInput!
  update: StepUpdateWithoutJournalEntriesDataInput!
}

input StepUpsertWithWhereUniqueWithoutJobInput {
  create: StepCreateWithoutJobInput!
  update: StepUpdateWithoutJobDataInput!
  where: StepWhereUniqueInput!
}

input StepUpsertWithWhereUniqueWithoutSectionInput {
  create: StepCreateWithoutSectionInput!
  update: StepUpdateWithoutSectionDataInput!
  where: StepWhereUniqueInput!
}

input StepWhereInput {
  AND: [StepWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  job: JobWhereInput
  jobId: IntFilter
  journalEntries: JournalEntryFilter
  name: StringFilter
  NOT: [StepWhereInput!]
  OR: [StepWhereInput!]
  order: NullableIntFilter
  section: SectionWhereInput
  sectionId: IntFilter
  successCriteria: NullableStringFilter
  updatedAt: DateTimeFilter
}

input StepWhereUniqueInput {
  id: Int
  name: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input UpdateFieldInput {
  create: Boolean
  editor: Boolean
  filter: Boolean
  id: String
  isId: Boolean
  kind: KindEnum
  list: Boolean
  name: String
  order: Int
  read: Boolean
  relationField: Boolean
  required: Boolean
  sort: Boolean
  title: String
  type: String
  unique: Boolean
  update: Boolean
  upload: Boolean
}

input UpdateModelInput {
  create: Boolean
  delete: Boolean
  displayFields: [String!]
  fields: [UpdateFieldInput!]
  idField: String
  name: String
  update: Boolean
}

type User {
  createdAt: DateTime!
  email: String!
  group: Group
  groupId: Int
  id: Int!
  name: String
  password: String!
}

type UserAvgAggregateOutputType {
  groupId: Float!
  id: Float!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  group: GroupCreateOneWithoutUsersInput
  name: String
  password: String!
}

input UserCreateManyWithoutGroupInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutGroupInput!]
}

input UserCreateWithoutGroupInput {
  createdAt: DateTime
  email: String!
  name: String
  password: String!
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregateOutputType {
  groupId: Int!
  id: Int!
}

type UserMinAggregateOutputType {
  groupId: Int!
  id: Int!
}

input UserOrderByInput {
  createdAt: OrderByArg
  email: OrderByArg
  groupId: OrderByArg
  id: OrderByArg
  name: OrderByArg
  password: OrderByArg
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  groupId: NullableIntFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
}

type UserSumAggregateOutputType {
  groupId: Int!
  id: Int!
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  group: GroupUpdateOneWithoutUsersInput
  id: Int
  name: String
  password: String
}

input UserUpdateManyDataInput {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
}

input UserUpdateManyMutationInput {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
}

input UserUpdateManyWithoutGroupInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutGroupInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutGroupInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutGroupDataInput {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
}

input UserUpdateWithWhereUniqueWithoutGroupInput {
  data: UserUpdateWithoutGroupDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutGroupInput {
  create: UserCreateWithoutGroupInput!
  update: UserUpdateWithoutGroupDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  group: GroupWhereInput
  groupId: NullableIntFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
